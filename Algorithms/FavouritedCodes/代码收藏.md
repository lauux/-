## LeetCode 代码收藏



### [15] 三数之和（3Sum）

#### Solutin # Python - 

``` python
#
# @lc app=leetcode.cn id=15 lang=python3
#
# [15] 三数之和
#

# @lc code=start
class Solution:
    def threeSum(self, nums: List[int]) -> List[List[int]]:
        
        size, res = len(nums), []
        if size < 3:
            return []

        nums.sort()
        for k in range(size - 2):
            if nums[k] > 0:
                break
            if k > 0 and nums[k] == nums[k-1]:
                continue
            l = k + 1
            r = size - 1

            while l < r:
                s = nums[k] + nums[l] + nums[r]
                if s == 0:
                    res.append([nums[k],nums[l],nums[r]])
                    l += 1
                    r -= 1
                    while l < r and nums[l] == nums[l-1]:
                        l += 1
                    while l < r and nums[r] == nums[r+1]:
                        r -= 1
                elif s < 0:
                    l += 1
                elif s > 0:
                    r -= 1

        return res

        
# @lc code=end


```



### [18] 四数之和（4Sum）

#### Solution #1 哈希表 / 转化为两数之和

巧妙地将4数之和转为2数之和问题，关键是使用哈希表保存所有可能的两数之和的值，哈希表key为两数之和，值为和为key的数对的下标列表。

需要注意的几点：

1. 算法本身不需要 `nums` 先排序，但是为了保证生成的结果顺序一致从而可以去重，依然要先进行排序；
   使用 `python` 的话，结果要暂存为 `tuple`，因为 `list` 是可变不可 `hash`，因此不能用来去重。
2. 时间复杂度可能还是 $O(n^3)$，因为worst case下 `map.get(target - key)` 包含 `n/2` 个元素，三重循环遍历复杂度为 $O(n^3)$。但是运行时间和加了剪枝的双指针差不多（180ms V.S. 120 ms），这就告诉我们一个道理：理论上的复杂度无法减小的话，加入条件剪枝可以在实际上获得很大的加速。

> 作者：symbolk
> 链接：https://leetcode-cn.com/problems/4sum/solution/fei-shuang-zhi-zhen-er-ha-xi-biao-jiang-4shu-zhi-h/
> 来源：力扣（LeetCode）
> 著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

```Python
    def fourSum(self, nums: List[int], target: int) -> List[List[int]]:
        N = len(nums)
        if N < 4:
            return []
        # use set to deduplicate
        res = set()
        nums.sort()
        # sum:[(index1, index2)]
        table = {}

        for i in range(N - 1):
            for j in range(i + 1, N):
                s = nums[i] + nums[j]
                if target - s in table:
                    for tmp in table[target - s]:
                        if tmp[1] < i:
                            # use tuple since it is hashable
                            res.add((nums[tmp[0]], nums[tmp[1]], nums[i], nums[j]))
                if s not in table:
                    table[s] = []
                table[s].append((i, j))
        # convert set to list
        ans = []
        for r in res:
            ans.append(list(r))
        return ans

作者：symbolk
链接：https://leetcode-cn.com/problems/4sum/solution/fei-shuang-zhi-zhen-er-ha-xi-biao-jiang-4shu-zhi-h/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
```



### [35] 搜索插入位置（Search Insert Position）

####  Solution # Python

```Python
class Solution:
    def searchInsert(self, nums: List[int], target: int) -> int:
        # 不管这个数在不在里面，直接append
        nums.append(target)
        # 然后再排序
        nums.sort()
        # 最后返回查找的index
        # 如果有多个target，index()只返回第一个匹配项
        return nums.index(target)

作者：nbcoder
链接：https://leetcode-cn.com/problems/search-insert-position/solution/pythonnei-zhi-fang-fa-chao-jian-dan-by-ljzecg/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
```



### [50] Pow(x, n)

#### Solution #1普通分治（最直接）

```python
class Solution:
    def myPow(self, x: float, n: int) -> float:
        if not n:
            return 1.0
        if not x:
            return 0
        if n == 1:
            return x
        if x == 1:
            return 1
        
        if n < 0:
            x = 1 / x
            return self.myPow(x, -n)
        half = self.myPow(x, n // 2)
        if n % 2:
            return x * half * half
        else:
            return half * half
```

#### Solution #2 分治 + 递归

```python
class Solution:
    def myPow(self, x: float, n: int) -> float:
      
        def helper(N: int) -> float:
            if not N:
                return 1.0
            y = helper(N // 2)
            return y * y * x if N % 2 else y * y
      
        return helper(n) if n >= 0 else 1.0 / helper(-n)
```

#### Solution #3 分治 + 迭代

```python
class Solution:
    def myPow(self, x: float, n: int) -> float:
        
        def helper(N: int) -> float:
            ans = 1.0
            xc = x
            if N % 2:
                ans *= xc
            xc *= xc
            N //= 2
           	
            return ans
        
        return helper(n) if n >= 0 else 1.0 / helper(-n)
```

#### Solution #4 分治 + 位运算

```python
class Solution:
    def myPow(self, x: float, n: int) -> float:
        if x == 0:
            return 0
        if n < 0:
            return myPow(1/x, -n)
        
        ans = 1.0
        while n:
            if n & 1:
                ans *= x
            x *= x
            n >> 1
        
        return ans
```



### [78] 子集（Subsets）

#### Solution #1 Python3 库函数

```Python
class Solution:
    def subsets(self, nums: List[int]) -> List[List[int]]:
        res = []
        for i in range(len(nums)+1):
            for tmp in itertools.combinations(nums, i):
                res.append(tmp)
        return res

作者：powcai
链接：https://leetcode-cn.com/problems/subsets/solution/hui-su-suan-fa-by-powcai-5/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
```

#### Solution #2 迭代

```Python
class Solution:
    def subsets(self, nums: List[int]) -> List[List[int]]:
        res = [[]]
        for i in nums:
            res += [[i] + sub for sub in res]
        return res

作者：powcai
链接：https://leetcode-cn.com/problems/subsets/solution/hui-su-suan-fa-by-powcai-5/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
```

#### Solution #3 递归（回溯）

##### 官方写法

```Python
class Solution:
    def subsets(self, nums: List[int]) -> List[List[int]]:
        def backtrack(first = 0, curr = []):
            # if the combination is done
            if len(curr) == k:  
                output.append(curr[:])
            for i in range(first, n):
                # add nums[i] into the current combination
                curr.append(nums[i])
                # use next integers to complete the combination
                backtrack(i + 1, curr)
                # backtrack
                curr.pop()
        
        output = []
        n = len(nums)
        for k in range(n + 1):
            backtrack()
        return output
```

##### 简约写法

```Python
class Solution:
    def subsets(self, nums: List[int]) -> List[List[int]]:
        res = []
        n = len(nums)
        
        def helper(i, tmp):
            res.append(tmp)
            for j in range(i, n):
                helper(j + 1,tmp + [nums[j]] )
        helper(0, [])
        return res  

作者：powcai
链接：https://leetcode-cn.com/problems/subsets/solution/hui-su-suan-fa-by-powcai-5/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
```



### [88] 合并两个有序数组（Merge Sorted Array）

#### Solution #1 双指针/从前往后

- **Time:** $O(n+m)$

- **Space:** $O(m)$

```Python
class Solution(object):
    def merge(self, nums1, m, nums2, n):
        """
        :type nums1: List[int]
        :type m: int
        :type nums2: List[int]
        :type n: int
        :rtype: void Do not return anything, modify nums1 in-place instead.
        """
        # Make a copy of nums1.
        nums1_copy = nums1[:m] 
        nums1[:] = []

        # Two get pointers for nums1_copy and nums2.
        p1 = 0 
        p2 = 0
        
        # Compare elements from nums1_copy and nums2
        # and add the smallest one into nums1.
        while p1 < m and p2 < n: 
            if nums1_copy[p1] < nums2[p2]: 
                nums1.append(nums1_copy[p1])
                p1 += 1
            else:
                nums1.append(nums2[p2])
                p2 += 1

        # if there are still elements to add
        if p1 < m: 
            nums1[p1 + p2:] = nums1_copy[p1:]
        if p2 < n:
            nums1[p1 + p2:] = nums2[p2:]
```

#### Solution #2 双指针/从后往前

- **Time:** $O(n+m)$

- **Space:** $O(1)$

![[88]Double Pointer](./pics/88_1.png)

```Python
class Solution(object):
    def merge(self, nums1, m, nums2, n):
        """
        :type nums1: List[int]
        :type m: int
        :type nums2: List[int]
        :type n: int
        :rtype: void Do not return anything, modify nums1 in-place instead.
        """
        # two get pointers for nums1 and nums2
        p1 = m - 1
        p2 = n - 1
        # set pointer for nums1
        p = m + n - 1
        
        # while there are still elements to compare
        while p1 >= 0 and p2 >= 0:
            if nums1[p1] < nums2[p2]:
                nums1[p] = nums2[p2]
                p2 -= 1
            else:
                nums1[p] =  nums1[p1]
                p1 -= 1
            p -= 1
        
        # add missing elements from nums2
        nums1[:p2 + 1] = nums2[:p2 + 1]

```



#### [97] 交错字符串

#### Solution #1 动态规划 / C

- **Time：**$O(n*m)$ 
- **Space：**$O(n*m)$

记 $n = |s_1|, m = |s_2|$

##### **思路与算法：**

首先如果 $|s_1| + |s_2| \ne |s_3|$ ，那 $s_3$ 必然不可能由 $s_1$ 和 $s_2$ 交错组成。在 $|s_1| + |s_2| = |s_3|$ 时，我们可以用动态规划来求解。我们定义 $f(i,j)$ 表示 $s_1$ 的前 $i$ 个元素和 $s_2$ 的前 $j$ 个元素是否能交错组成 $s_3$ 的前 $i + j$ 个元素。如果 $s_1$ 的第 $i$ 个元素和 $s_3$ 的第 $i+j$ 个元素相等，那么 $s_1$ 的前 $i$ 个元素和 $s_2$ 的前 $j$ 个元素是否能交错组成 $s_3$ 的前 $i+j$ 个元素取决于 $s_1$ 的前 $i-1$ 个元素和 $s_2$ 的前 $j$ 个元素是否能交错组成 $s_3$ 的前 $i+j-1$ 个元素，即此时 $f(i,j)$ 取决于 $f(i-1,j)$，在此情况下如果 $f(i-1,j)$ 为真，则 $f(i,j)$ 也为真。同样的，如果 $s_2$ 的第 $j$ 个元素和 $s_3$ 的第 $i+j$ 个元素相等并且 $f(i,j-1)$为真，则$f(i,j)$ 也为真。于是可以推导出这样的动态规划转移方程：

$f(i,j) = [f(i-1, j)\ and\ s_1(i-1) == s_3(p)]\ or\ [f(i, j-1)\ and\ s_2(j-1) == s_3(p)]$

其中 $p=i+j-1$ 。边界条件为 $f(0,0) = True$。

```C
bool isInterleave(char* s1, char* s2, char* s3) {
    int n = strlen(s1), m = strlen(s2), t = strlen(s3);

    int f[n + 1][m + 1];
    memset(f, 0, sizeof(f));

    if (n + m != t) {
        return false;
    }

    f[0][0] = true;
    for (int i = 0; i <= n; ++i) {
        for (int j = 0; j <= m; ++j) {
            int p = i + j - 1;
            if (i > 0) {
                f[i][j] |= (f[i - 1][j] && s1[i - 1] == s3[p]);
            }
            if (j > 0) {
                f[i][j] |= (f[i][j - 1] && s2[j - 1] == s3[p]);
            }
        }
    }

    return f[n][m];
}

```

#### Solution #2 动态规划 / C / 使用滚动数组优化空间复杂度

- **Time：**$O(n*m)$ 
- **Space：**$O(m)$

**使用滚动数组优化空间复杂度**。 因为这里数组 $f$ 的第 $i$ 行只和第$i-1$ 行相关，所以我们可以用滚动数组优化这个动态规划，这样空间复杂度可以变成 $O(m)$。

```C
bool isInterleave(char* s1, char* s2, char* s3) {
    int n = strlen(s1), m = strlen(s2), t = strlen(s3);

    int f[m + 1];
    memset(f, 0, sizeof(f));

    if (n + m != t) {
        return false;
    }

    f[0] = true;
    for (int i = 0; i <= n; ++i) {
        for (int j = 0; j <= m; ++j) {
            int p = i + j - 1;
            if (i > 0) {
                f[j] &= (s1[i - 1] == s3[p]);
            }
            if (j > 0) {
                f[j] |= (f[j - 1] && s2[j - 1] == s3[p]);
            }
        }
    }

    return f[m];
}

```

此思想可应用于 [63], [70], 剑指46



### [102] 二叉树多层序遍历（Binary Tree Level Order Traversal）

#### Solution #1 DFS 递归

```python
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, x):
#         self.val = x
#         self.left = None
#         self.right = None

class Solution:
    def levelOrder(self, root: TreeNode) -> List[List[int]]:

        def dfs(root: TreeNode, li: List[int], levl: int) -> List[List[int]]:
            if not root:
                return []
            
            if len(li) == levl:
                li.append([])
            
            li[levl].append(root.val)
            dfs(root.left, li, levl + 1)
            dfs(root.right, li, levl + 1)

            return li

        return dfs(root, [], 0)
```

#### Solution #2 BFS 简洁写法 

设置 `queue` 列表值为 `(root,)`，之所以需要加 `,` 是因为后面为空值，但是需要两个值，一个不行。设置value列表保存结果
开始循环 `queue`，`res.append`算 `val`，`for tup in queue` 是将 `[(root,)]` 解开 `[]`，变为 `(root,)`，`for node in tup` 是解开 `(root,)`，然后逐个循环，接着判断 `node` 是否为空，若非空则将 `node.val` 加入 `res`。
`queue` 也类似，解开 `[(root,)]` 然后判断是否有左右节点，有的话重置 `queue`，因为前面 `queue` 的值 `val` 加过了，所以可以看成将之前的 `queue.pop` 然后重新加入新的值
最后输出 `res`，但是因为如果到了最后一个节点，那么这个最后节点还有一个 `null` 的节点，所以会多出来一个 `[]`，所以这里只需要取得 `[:-1]` 即可。

作者：luo_luo
链接：https://leetcode-cn.com/problems/binary-tree-level-order-traversal/solution/er-cha-shu-de-ceng-xu-bian-li-python3yan-du-you-xi/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

```python
class Solution:
    def levelOrder(self, root: TreeNode) -> List[List[int]]:

        res, queue = [], [(root,)]
        while queue:
            res.append([node.val for tup in queue for node in tup if node])
            queue = [(node.left, node.right) for tup in queue for node in tup if node]

        return res[:-1]
```



### [169] 多数元素（Majority Element）

#### Solution 1# 分治

```python
class Solution:
    def majorityElement(self, nums: List[int]) -> int:
        
        def helper(lo: int, hi: int) -> int:
            if lo == hi:
                return nums[lo]
            
            mid = (hi - lo) // 2 + lo
            left = helper(lo, mid)
            right = helper(mid + 1, hi)

            if left == right:
                return left
            
            cntleft = sum(1 for i in range(lo, hi + 1) if nums[i] == left)
            cntright = sum(1 for i in range(lo, hi + 1) if nums[i] == right)

            return left if cntleft > cntright else right
        
        return helper(0, len(nums) - 1)
```

#### Solution 2# Boyer-Moore 投票算法

```Python
class Solution:
    def majorityElement(self, nums):
        count = 0
        candidate = None

        for num in nums:
            if count == 0:
                candidate = num
            count += (1 if num == candidate else -1)

        return candidate
```



### [189] 旋转数组（Rotate Array）

#### Solution #1 暴力遍历（思路，LeetCode中无法AC，超时）

- **Time：**$O(N*K)$ 
- **Space：**$O(1)$

```Python
class Solution:
    def rotate(self, nums, k):
        """
        :type nums: List[int]
        :type k: int
        :rtype: None Do not return anything, modify nums in-place instead.
        """
        for _ in range(k):
            previous = nums[-1] # initiate a first previous 
            for i in range(len(nums)):
                temp = nums[i] # hold nums[i]
                nums[i] = previous # overwrite the current index 
                previous = temp # swap the value 
```

#### Solution #2 新建数组替换（但是不符合题目要求，题目要求空间$O(1)$ ）

- **Time：**$O(N)$ 
- **Space：**$O(N)$

```Python
class Solution:
    def rotate(self, nums, k):
        """
        :type nums: List[int]
        :type k: int
        :rtype: None Do not return anything, modify nums in-place instead.
        """
        a = [0] * len(nums)
        for i in range(len(nums)):
            a[(i+k)%len(nums)] = nums[i] # recycle

        for i in range(len(nums)):
            nums[i] = a[i]
```

#### Solution #3 循环替换

- **Time：**$O(N)$ 
- **Space：**$O(1)$

![Rotate Array #3 Cyclic Replacement](./pics/189_1.png)

```python
class Solution:
    def rotate(self, nums, k):
        """
        :type nums: List[int]
        :type k: int
        :rtype: None Do not return anything, modify nums in-place instead.
        """
        k = k % len(nums)
        count = 0
        start = 0
        while count < len(nums):
            current = start 
            prev = nums[start] # store the value in the position
            
            while True:
                next = (current + k) % len(nums) #
                temp = nums[next] # store it temporaly 
                nums[next] = prev # overide the next 
                prev = temp # reset prev
                current = next # reset current
                count += 1

                if start == current:
                    break 
            
            start += 1
```

#### Solution #4 翻转

- **Time：**$O(N)$ 
- **Space：**$O(1)$

此方法利用了：当我们向右移动数组 `k` 次的时候，数组末尾的 `k % n` 个元素会移动到数组前端，而剩余的 `n - k` 个元素则向后移动。因此，我们先将整个数组翻转（Reverse），然后将前 `k` 个元素再次翻转回原顺序，最后将后 `n - k` 个元素翻转回原顺序，则可以得到最终结果。

令 `n = 7 and k = 3`，则有

```c
Original List                   : 1 2 3 4 5 6 7
After reversing all numbers     : 7 6 5 4 3 2 1
After reversing first k numbers : 5 6 7 4 3 2 1
After revering last n-k numbers : 5 6 7 1 2 3 4 --> Result
```

```Python
class Solution:
    def rotate(self, nums, k) -> None:
        """
        :type nums: List[int]
        :type k: int
        :rtype: None Do not return anything, modify nums in-place instead.
        """
        k %= len(nums)
        self.reverse(nums,0,len(nums)-1)
        self.reverse(nums,0, k-1)
        self.reverse(nums,k, len(nums)-1)

    def reverse(self, nums, start, end) -> None:
        """
        :type nums: List[int]
        :type start: int
        :type end: int
        :rtype: None
        """
        while start < end: #
            temp = nums[start]
            nums[start] = nums[end]
            nums[end] = temp 
            start += 1
            end -= 1
```



### [239] 滑动窗口的最大值（Sliding Window Maximum）

#### Solution # 索引堆

动态得到“滑动窗口”的最大值，有一个数据结构是容易想到的，那就是“堆”（“优先队列”），但是问题来了。当“滑动窗口”要把左边界移除的时候，我们虽然左边界是哪个元素，但是没有从一个堆中移除非最堆顶元素的操作，于是我就想“索引堆”可不可以呢？找到即将要滑出边界的那个索引，更新一下它的值就好，那么索引值如何更新呢？

规律：新进来的那个数的索引，把自己这个索引对 $k$ 取模的那个索引更新一下就好了。

使用“索引堆”的原因：“索引堆”有一个更新操作，可以针对某个索引更新它的值，然后索引发生调整，使得索引数组组成最大堆。因为能方便地定位到某个元素，因此可以在新进来一个数的时候，使用更新操作，把马上要出“滑动窗口”的那个索引位置上的值更新成新进来的这个数的值就可以了（说起来很拗口，看代码会简洁很多）。

```Python
from typing import List


class Solution:

    def maxSlidingWindow(self, nums: List[int], k: int) -> List[int]:
        size = len(nums)

        # 特判
        if size == 0:
            return []

        # 初始化最大索引堆，其容量是滑动窗口的大小
        index_max_heap = Solution.IndexMaxHeap(k)
        # 首先先把前 k 个元素加进去
        for i in range(k):
            index_max_heap.insert(i, nums[i])

        # 结果集
        res = []
        # 然后就是产生滑动窗口的过程，先输出最大值，
        # 而后把当前考虑的数插入到将要滑出的左边界的索引位置

        for i in range(k, size):
            res.append(index_max_heap.peek_max_value())
            index_max_heap.change(i % k, nums[i])
        # 因为最大索引堆更新了最后 1 个数，因此最后还要看一眼最大值
        res.append(index_max_heap.peek_max_value())
        return res

    class IndexMaxHeap:
        def __init__(self, capacity):
            self.data = [None for _ in range(capacity + 1)]
            # 初值设置为 0 ，表示该位置还没有放置元素
            self.indexes = [0 for _ in range(capacity + 1)]
            self.reverse = [0 for _ in range(capacity + 1)]
            self.count = 0
            self.capacity = capacity

        def size(self):
            return self.count

        def is_empty(self):
            return self.count == 0

        # 此时 insert 要给一个索引位置
        def insert(self, i, item):
            if self.count + 1 > self.capacity:
                raise Exception('堆的容量不够了')
            i += 1
            self.data[i] = item

            # 这一步很关键，在内部索引数组的最后设置索引数组的索引
            self.indexes[self.count + 1] = i
            self.reverse[i] = self.count + 1

            self.count += 1
            self.__shift_up(self.count)

        def __shift_up(self, k):
            while k > 1 and self.data[self.indexes[k // 2]] < self.data[self.indexes[k]]:
                self.indexes[k // 2], self.indexes[k] = self.indexes[k], self.indexes[k // 2]

                self.reverse[self.indexes[k // 2]] = k // 2
                self.reverse[self.indexes[k]] = k

                k //= 2

        def extract_max(self):
            if self.count == 0:
                raise Exception('堆里没有可以取出的元素')
            ret = self.data[self.indexes[1]]
            self.indexes[1], self.indexes[self.count] = self.indexes[self.count], self.indexes[1]
            self.reverse[self.indexes[1]] = 1
            self.reverse[self.indexes[self.count]] = self.count

            self.reverse[self.indexes[self.count]] = 0

            self.count -= 1
            self.__shift_down(1)
            return ret

        def __shift_down(self, k):
            while 2 * k <= self.count:
                j = 2 * k
                if j + 1 <= self.count and self.data[self.indexes[j + 1]] > self.data[self.indexes[j]]:
                    j = j + 1
                if self.data[self.indexes[k]] >= self.data[self.indexes[j]]:
                    break
                self.indexes[k], self.indexes[j] = self.indexes[j], self.indexes[k]

                self.reverse[self.indexes[k]] = k
                self.reverse[self.indexes[j]] = j

                k = j

        # 新增方法
        def extract_max_index(self):
            assert self.count > 0
            # 减 1 是为了符合用户视角
            ret = self.indexes[1] - 1
            self.indexes[1], self.indexes[self.count] = self.indexes[self.count], self.indexes[1]
            self.count -= 1
            self.__shift_down(1)
            return ret

        # 新增方法
        def get_item(self, i):
            # 内部数组的索引比用户视角多 1
            return self.data[i + 1]

        # 新增方法
        def change(self, i, new_item):
            # 把用户视角改成内部索引
            i += 1
            self.data[i] = new_item

            # 重点：下面这一步是找原来数组中索引是 i 的元素
            # 在索引数组中的索引是几，这是一个唯一值，找到即返回
            # 优化：可以引入反向查找技术优化

            j = self.reverse[i]
            self.__shift_down(j)
            self.__shift_up(j)

        # 为 LeetCode 第 239 题新增的方法，看一眼此时索引堆的最大索引是多少（没用上，我想多了，留到以后用吧）
        def peek_max_index(self):
            if self.count == 0:
                raise Exception('堆里没有可以取出的元素')
            # 注意：与用户认为的索引值有一个偏差
            return self.indexes[1] - 1

        # 为 LeetCode 第 239 题新增的方法，看一眼此时索引堆的最大值是多少
        def peek_max_value(self):
            if self.count == 0:
                raise Exception('堆里没有可以取出的元素')
            return self.data[self.indexes[1]]


# if __name__ == '__main__':
#     solution = Solution()
#     nums = [1, 3, -1, -3, 5, 3, 6, 7]
#     k = 3
#     res = solution.maxSlidingWindow(nums, k)
#     print(res)

作者：liweiwei1419
链接：https://leetcode-cn.com/problems/sliding-window-maximum/solution/zui-da-suo-yin-dui-shuang-duan-dui-lie-cun-suo-yin/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
```



### [283] 移动零 （Move Zeros）

#### Solution # Python / 使用按bool类型降序排序

```Python
class Solution:
    def moveZeroes(self, nums: List[int]) -> None:
        """
        Do not return anything, modify nums in-place instead.
        """
        nums.sort(key = bool, reverse = True)
```



### [337] 打家劫舍III

#### Solution #1 DFS/DP

```python
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, x):
#         self.val = x
#         self.left = None
#         self.right = None

class Solution:
    def rob(self, root: TreeNode) -> int:
        def dfs(node: TreeNode) -> List[int]:
            if not node:
                return [0, 0]
            
            left = dfs(node.left)
            right = dfs(node.right)

            dp = [0] * 2
            
            dp[0] = max(left[0], left[1]) + max(right[0], right[1])
            dp[1] = node.val + left[0] + right[0]

            return dp

        res = dfs(root)
        return max(res[0], res[1])
```

#### Solution #2 复数

>  来自国际站大佬 [StefanPochmann](https://leetcode.com/stefanpochmann) 题解

```python
def rob(self, root):
    def rob(root):
        if not root:
            return 0
        z = root.val * 1j + rob(root.left) + rob(root.right)
        return max(z.real, z.imag) + z.real * 1j
    return int(rob(root).real)
  
#### Short version
def rob(self, root):
    def rob(root):
        z = root.val * 1j + rob(root.left) + rob(root.right) if root else 0
        return max(z.real, z.imag) + z.real * 1j
    return int(rob(root).real)
```

The helper function returns a complex number. The real part tells, well, the real answer (maximum amount with or without robbing the (sub)tree's root). The imaginary part tells the maximum amount without robbing the root. (But in the temporary variable `z`, the real part is the amount without the root and the imaginary part is the amount with the root.)

#### Solution #3 Tuple

>  来自国际站大佬 [StefanPochmann](https://leetcode.com/stefanpochmann) 题解

Here the helper returns a tuple, first element being the real answer and second element being the without-root answer. Variables "y/n" mean yes/no, telling whether the subtree's root might be robbed.

```python
def rob(self, root):
    def rob(root):
        if not root:
            return 0, 0
        y, n = rob(root.left)
        Y, N = rob(root.right)
        return max(root.val + n + N, y + Y), y + Y
    return rob(root)[0]
```

A variation

```python
def rob(self, root):
    def rob(root):
        if not root:
            return 0, 0
        y, n = map(sum, zip(rob(root.left), rob(root.right)))
        return max(root.val + n, y), y
    return rob(root)[0]
```

Another:

```python
def rob(self, root):
    def rob(root):
        y, n = map(sum, zip(rob(root.left), rob(root.right), (0, root.val))) if root else (0, 0)
        return max(y, n), y
    return rob(root)[0]
```



### [367] 

#### Solution # 数学方法

通过以下规律

1 = 1

4 = 1 + 3

9 = 1 + 3 + 5

16 = 1 + 3 + 5 + 7

...

n^2 = n个从1开始的连续奇数之和

```python
class Solution:
    def isPerfectSquare(self, num: int) -> bool:

        x = 1
        while num > 0:
            num -= x
            x += 2
        
        return num == 0
```



### [641] 设计循环双端队列（Design Circular Deque）

#### Solution # Python / 通过取模运算来实现循环（Circular）

```Python
class MyCircularDeque:

    def __init__(self, k: int):
        """
        Initialize your data structure here. Set the size of the deque to be k.
        """
        self.front = 0
        self.rear = 0
        self.capacity = k + 1
        self.arr = [0 for _ in range(self.capacity)]

    def insertFront(self, value: int) -> bool:
        """
        Adds an item at the front of Deque. Return true if the operation is successful.
        """
        if self.isFull():
            return False
        self.front = (self.front - 1 + self.capacity) % self.capacity
        self.arr[self.front] = value
        return True

    def insertLast(self, value: int) -> bool:
        """
        Adds an item at the rear of Deque. Return true if the operation is successful.
        """
        if self.isFull():
            return False
        self.arr[self.rear] = value
        self.rear = (self.rear + 1) % self.capacity
        return True

    def deleteFront(self) -> bool:
        """
        Deletes an item from the front of Deque. Return true if the operation is successful.
        """
        if self.isEmpty():
            return False
        self.front = (self.front + 1) % self.capacity
        return True

    def deleteLast(self) -> bool:
        """
        Deletes an item from the rear of Deque. Return true if the operation is successful.
        """
        if self.isEmpty():
            return False
        self.rear = (self.rear - 1 + self.capacity) % self.capacity;
        return True

    def getFront(self) -> int:
        """
        Get the front item from the deque.
        """
        if self.isEmpty():
            return -1
        return self.arr[self.front]

    def getRear(self) -> int:
        """
        Get the last item from the deque.
        """
        if self.isEmpty():
            return -1
        return self.arr[(self.rear - 1 + self.capacity) % self.capacity]

    def isEmpty(self) -> bool:
        """
        Checks whether the circular deque is empty or not.
        """
        return self.front == self.rear

    def isFull(self) -> bool:
        """
        Checks whether the circular deque is full or not.
        """
        return (self.rear + 1) % self.capacity == self.front

作者：liweiwei1419
链接：https://leetcode-cn.com/problems/design-circular-deque/solution/shu-zu-shi-xian-de-xun-huan-shuang-duan-dui-lie-by/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
```



### [429] N叉树的层序遍历（N-ary Tree Level Order Traversal）

#### Solution # Python / BFS

首先判断`root`是否有内容，如果没有则输出`[]`
设置两个列表`queue, res`，前者存放节点，后者存放值
开始循环，通过`for`循环将`queue`里面的值分离出来一次性加入`res`中，
`queue`队列通过两个`for`循环，前面一个取出`queue`的节点，后一个将取出的节点再去子节点，然后得到`queue`
最后循环结束输出`res`

```Python
"""
# Definition for a Node.
class Node:
    def __init__(self, val=None, children=None):
        self.val = val
        self.children = children
"""

class Solution:
    def levelOrder(self, root: 'Node') -> List[List[int]]:

        if not root:
            return []
        
        queue, res = [root], []
        while queue:
            res.append(node.val for node in queue)
            queue = [child for node in queue for child in node.children]
        
        return res
      
作者：luo_luo
链接：https://leetcode-cn.com/problems/n-ary-tree-level-order-traversal/solution/ncha-shu-de-ceng-xu-bian-li-python3yan-du-you-xian/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
```



### [453] 最小移动次数使数组元素相等（Minimum Moves to Equal Array Elements）

#### Solution # 数学方法

让 $n-1$ 个数加 $1$ 即让 $1$ 个数减 $1$

```Python
class Solution:
    def minMoves(self, nums: List[int]) -> int:
        minNum = min(nums)
        nums.remove(minNum)
        return sum(nums) - minNum * len(nums)

```



### [498] 对角线遍历（Diagonal Traverse ）

#### Solution #1 对角线迭代和翻转

```python
class Solution:
    def findDiagonalOrder(self, matrix: List[List[int]]) -> List[int]:
        if not matrix:
            return []

        res, interm = [], []
        m, n = len(matrix), len(matrix[0])

        for d in range(m + n - 1):
            interm.clear()

            r, c = 0 if d < n else d - n + 1, d if d < n else n - 1

            while r < m and c > -1:
                interm.append(matrix[r][c])
                r += 1
                c -= 1
            
            if d % 2:
                res.extend(interm)
            else:
                res.extend(interm[::-1])
        
        return res
```

#### Solution #2 利用对角线坐标和相等

```python
class Solution:
    def findDiagonalOrder(self, matrix: List[List[int]]) -> List[int]:
        res, m, n = [], len(matrix), len(matrix[0])
        dic = collections.defaultdict(list)
        
        for i in range(m):
            for j in range(n):
                dic[i+j].append(matrix[i][j])
        
        flag = 0
        for _, i in sorted(dic.items()):
            if flag:
                res.extend(i)
            else:
                res.extend(i[::-1])
            flag ^= 1
        
        return res
```



### [785] 判断二分图 （Is Graph Bipartite?）

#### Solution #1 C / BFS 广度优先搜索

- **Time** :  $O(N+M)$，其中 $N$ 和 $M$ 分别是无向图中的点数和边数。

- **Space**：$O(N)$，存储节点颜色的数组需要 $O(N)$ 的空间，并且在广度优先搜索的过程中，队列中最多有 $N-1$ 个节点，需要 $O(N)$ 的空间。

```C
#define UNCOLOURED 0
#define RED 1
#define GREEN 2

bool isBipartite(int** graph, int graphSize, int* graphColSize){
    int* colour = (int*)malloc(sizeof(int) * graphSize);
    memset(colour, 0, sizeof(int) * graphSize);

    int* q = (int*)malloc(sizeof(int) * graphSize);
    for(int i = 0; i < graphSize; i++){
        if(colour[i] == UNCOLOURED){      
            int l = 0, r = 0;
            q[0] = i;
            colour[i] = RED;
            while(l <= r){
                int node = q[l++];
                int cNei = (colour[node] == RED ? GREEN : RED);
                for(int j = 0; j < graphColSize[node]; j++){
                    int neighbour = graph[node][j];
                    if(colour[neighbour] == UNCOLOURED){
                        q[++r] = neighbour;
                        colour[neighbour] = cNei;
                    }else if(colour[neighbour] != cNei){
                        free(colour);
                        free(q);
                        return false;
                    }
                }
            }
        }
    }
    free(colour);
    free(q);
    return true;
}

作者：LeetCode-Solution
链接：https://leetcode-cn.com/problems/is-graph-bipartite/solution/pan-duan-er-fen-tu-by-leetcode-solution/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
```

#### Solution #2 C / DFS 深度优先搜索

- **Time** :  $O(N+M)$，其中 $N$ 和 $M$ 分别是无向图中的点数和边数。

- **Space**：$O(N)$，存储节点颜色的数组需要 $O(N)$ 的空间，并且在深度优先搜索的过程中，栈的深度最大为 $N$，需要 $O(N)$ 的空间。

```c
bool dfs(int node, int c, int* color, int** graph, int* graphColSize) {
    color[node] = c;
    int cNei = (c == 1 ? 2 : 1);
    for (int i = 0; i < graphColSize[node]; ++i) {
        int neighbor = graph[node][i];
        if (color[neighbor] == 0) {
            if (!dfs(neighbor, cNei, color, graph, graphColSize)) {
                return false;
            }
        } else if (color[neighbor] != cNei) {
            return false;
        }
    }
    return true;
}

bool isBipartite(int** graph, int graphSize, int* graphColSize) {
    int* color = (int*)malloc(sizeof(int) * graphSize);
    memset(color, 0, sizeof(int) * graphSize);
    for (int i = 0; i < graphSize; ++i) {
        if (color[i] == 0) {
            if (!dfs(i, 1, color, graph, graphColSize)) {
                free(color);
                return false;
            }
        }
    }
    free(color);
    return true;
}

作者：LeetCode-Solution
链接：https://leetcode-cn.com/problems/is-graph-bipartite/solution/pan-duan-er-fen-tu-by-leetcode-solution/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
```



### [JZ11] 旋转数组的最小数字 LCOF

#### Solution # Python / 二分查找

-  **Times：** $O(\log N)$ 在特例情况下（例如 $[1,1,1,1]$），会退化到 $O(N)$。
- **Space：** $O(1)$ ： `left, right, m`指针使用常数大小的额外空间。



##### **解法思路：**

- 如下图所示，寻找旋转数组的最小元素即为寻找 右排序数组 的首个元素 numbers[x] ，称 xx 为 旋转点 。

- 排序数组的查找问题首先考虑使用 二分法 解决，其可将遍历法的 线性级别 时间复杂度降低至 对数级别 。

  <img src="./pics/JZ11_1.png" style="zoom:40%;" />

##### **算法流程**：

- 循环二分： 设置`left`, `right`指针分别指向 `numbers` 数组左右两端，`m = (i + j) // 2` 为每次二分的中点（ `//`代表向下取整除法，因此恒有 $left \le m \le right$ ），可分为以下三种情况:

  - 当 `numbers[m] < numbers[right]` 时：  `m`  一定在 右排序数组 中，即旋转点 `x`  一定在 $[left, m]$闭区间内，因此执行 `right = m`；

  - 当 `numbers[m] > numbers[right]`时： `m` 一定在 左排序数组 中，即旋转点 `x` 一定在 $[m + 1, right]$ 闭区间内，因此执行 `left = m + 1`；

  - 当 `numbers[m] == numbers[right]` 时： 无法判断 `m` 在哪个排序数组中，即无法判断旋转点 `x`  在 $[left, m]$ 还是 $[m + 1, right]$ 区间中。解决方案： 执行 `right = right - 1` 缩小判断范围 （分析见以下内容） 。

    - **无法判定 `m` 在左（右）排序数组：** 设以下两个旋转点值为 $0$ 的示例数组，则当 `left = 0, right = 4` 时 `m = 2` ，两示例结果不同。

      1. 例 $[1,0,1,1,1]$ ：旋转点 `x = 1` ，因此 `m = 2` 在**右排序数组**中。
      2. 例 $[1,1,1,0,1]$ ：旋转点 `x = 3` ，因此 `m = 2` 在**左排序数组**中。

    - **`right = right - 1` 操作的正确性证明：** 只需证明每次执行此操作后，旋转点 `x` 仍在 $[left,right]$ 区间内即可。

      1. **若 `m` 在右排序数组中：** `numbers[m] == numbers[right]`，因此数组 $[m,right]$（恒有 $m < right$）区间内所有元素值相等，执行 `j = j - 1` 只会抛弃一个重复值，因此旋转点 `x` 仍在 $[left,right]$ 区间内。

      2. **若 `m` 在左排序数组中：** 由于左排序数组任一元素 >= 右排序数组任一元素 ，因此可推出旋转点元素值 `numbers[x] <= numbers[right] == numbers[m]`，则有：

         - 若 `numbers[x] < numbers[right]` ： 即 `right` 左方仍有值更小的元素，执行 `right = right - 1` 后旋转点 `x` 仍在 $[left,right]$ 区间内。

         - 若 `numbers[x] == numbers[right]` ： 分为以下两种情况。

           1. 当 `right > x` ： 易得执行 `j = j - 1` 后旋转点 `x` 仍在 $[i,j]$ 区间内。

           2. 当 `right == x`： 特殊情况，即执行 `right - 1` 后旋转点 `x` 可能不在 $[i,j]$ 区间内。

              例如 [$1,1,1,2,3,1]$ ，当 `left = 0, m = 2, right = 5` 时执行 j = j - 1j=j−1 后虽然 丢失了旋转点索引 x = 5x=5 ，但最终返回值仍正确（最终返回的 `numbers[0]` 等于旋转点值 `numbers[5]` ），这是因为：之后的二分循环一直在执行 `right = m`，而区间 $[left,m]$ 内的元素值一定都等于旋转点值 `numbers[x]` （ 因为区间内元素值既要满足 `>=` 也要满足 `<= numbers[x]`） ，因此 仍可保证正确的返回值 。

- **总结**： 此方法可以保证返回值 `numbers[left]` 等于旋转点值 `numbers[x]` ；但在少数特例下 `left` 不是旋转点 `x` 。本题目只要求返回 “旋转点的值” ，因此本方法可行。

>思考： 是否可以用 `numbers[m]` 和 `numbers[left]` 比较做代替？
>解析： 不可以。因为做比较的目的是判断 `m` 在哪个排序数组中。但在 `numbers[m] > numbers[left]`情况下，无法判断 `m` 在哪个排序数组中。本质是因为 `right` 初始值肯定在右排序数组中； `left` 初始值无法确定在哪个排序数组中。
>示例： 当 `left = 0, right = 4, m = 2` 时，有 `numbers[m] > numbers[left]` ，以下两示例得出不同结果。
>`numbers = [1, 2, 3, 4 ,5]` 旋转点 `x = 0` ： `m` 在右排序数组（此示例只有右排序数组）；
>`numbers = [3, 4, 5, 1 ,2]` 旋转点 `x = 3`： `m` 在左排序数组。

##### 代码：Python

```Python
class Solution:
    def minArray(self, numbers: [int]) -> int:
        left, right = 0, len(numbers) - 1
        while i < j:
            m = (i + j) // 2
            if numbers[m] > numbers[j]: i = m + 1
            elif numbers[m] < numbers[j]: j = m
            else: j -= 1
        return numbers[i]

作者：jyd
链接：https://leetcode-cn.com/problems/xuan-zhuan-shu-zu-de-zui-xiao-shu-zi-lcof/solution/mian-shi-ti-11-xuan-zhuan-shu-zu-de-zui-xiao-shu-3/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
```



### 动态规划 Dynamic Programming

具有最优子结构性质以及重叠子问题性质的问题可以通过动态规划求解。

##### 最优子结构

- 如果一个问题的最优解包含其子问题的最优解，我们就称此问题具有**最优子结构**。
- 一个问题具有最优子结构，可能使用动态规划方法，也可能使用贪心方法。所以最优子结构只是一个线索，不是看到有最优子结构就一定是用动态规划求解

##### 重叠子问题

- 子问题空间必须足够“小”，即在不断的递归过程中，是在反复求解大量相同的子问题，而不是每次递归时都产生新的子问题。
- 一般的，不同子问题的总数是输入规模的多项式函数为好
- 如果递归算法反复求解相同的子问题，我们就称最优化问题具有重叠子问题性质

##### 从分治到动态规划

对于**分治**解法，我们的计算过程分为两个阶段：

1. 递归的不断的分解问题，直到问题不可继续分解。
2. 当问题不可继续分解，也就是分解到最小子问题后，由最小子问题的解逐步向上回归，逐层求出上层问题的解。

阶段1我们称为**递归过程**，而阶段2我们称为递归调用的**回归过程**。我们要做的，就是省略递归分解子问题的过程，将阶段2用递推实现出来。

